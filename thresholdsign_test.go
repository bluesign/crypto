// +build relic

package crypto

import (
	"sync"
	"testing"
	"time"

	log "github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
)

func TestThresholdSignature(t *testing.T) {
	t.Run("Stateful Threshold signature with keys generated by Feldman VSS", testThresholdSignatureFeldmanVSS)
	t.Run("Stateful Threshold signature with keys generated by Joint-Feldman", testThresholdSignatureJointFeldman)
	t.Run("Stateless Threshold signature with keys generated by Joint-Feldman", testStatelessThresholdSignatureFeldmanVSS)
}

// Testing Threshold Signature stateful api
// keys are generated using simple Feldman VSS
func testThresholdSignatureFeldmanVSS(t *testing.T) {
	log.SetLevel(log.ErrorLevel)
	log.Info("DKG starts")
	// number of nodes to test
	n := 5
	lead := 0
	var sync sync.WaitGroup
	chans := make([]chan *message, n)
	processors := make([]testDKGProcessor, 0, n)

	// create n processors for all nodes
	for current := 0; current < n; current++ {
		processors = append(processors, testDKGProcessor{
			current: current,
			chans:   chans,
			msgType: dkgType,
		})
		// create DKG in all nodes
		var err error
		processors[current].dkg, err = NewDKG(FeldmanVSS, n, current,
			&processors[current], lead)
		assert.Nil(t, err)
	}

	// create the node (buffered) communication channels
	for i := 0; i < n; i++ {
		chans[i] = make(chan *message, 2*n)
	}
	// start DKG in all nodes
	seed := []byte{1, 2, 3}
	sync.Add(n)
	for current := 0; current < n; current++ {
		err := processors[current].dkg.StartDKG(seed)
		assert.Nil(t, err)
		go tsDkgRunChan(&processors[current], &sync, t, 2)
	}

	// synchronize the main thread to end DKG
	sync.Wait()
	for i := 1; i < n; i++ {
		assert.Equal(t, processors[i].pkBytes, processors[0].pkBytes, "2 group public keys are mismatching")
	}

	// Start TS
	log.Info("TS starts")
	sync.Add(n)
	for i := 0; i < n; i++ {
		go tsRunChan(&processors[i], &sync, t)
	}
	// synchronize the main thread to end TS
	sync.Wait()
}

// Testing Threshold Signature stateful api
// keys are generated using Joint-Feldman
func testThresholdSignatureJointFeldman(t *testing.T) {
	log.SetLevel(log.ErrorLevel)
	log.Info("DKG starts")
	// number of nodes to test
	n := 5
	lead := 0
	var sync sync.WaitGroup
	chans := make([]chan *message, n)
	processors := make([]testDKGProcessor, 0, n)

	// create n processors for all nodes
	for current := 0; current < n; current++ {
		processors = append(processors, testDKGProcessor{
			current: current,
			chans:   chans,
			msgType: dkgType,
		})
		// create DKG in all nodes
		var err error
		processors[current].dkg, err = NewDKG(JointFeldman, n, current,
			&processors[current], lead)
		assert.Nil(t, err)
	}

	// create the node (buffered) communication channels
	for i := 0; i < n; i++ {
		chans[i] = make(chan *message, 2*n)
	}
	// start DKG in all nodes but the leader
	seed := []byte{1, 2, 3}
	sync.Add(n)
	for current := 0; current < n; current++ {
		err := processors[current].dkg.StartDKG(seed)
		assert.Nil(t, err)
		go tsDkgRunChan(&processors[current], &sync, t, 0)
	}

	// sync the 2 timeouts at all nodes and start the next phase
	for phase := 1; phase <= 2; phase++ {
		sync.Wait()
		sync.Add(n)
		for current := 0; current < n; current++ {
			go tsDkgRunChan(&processors[current], &sync, t, phase)
		}
	}

	// synchronize the main thread to end DKG
	sync.Wait()
	for i := 1; i < n; i++ {
		assert.Equal(t, processors[i].pkBytes, processors[0].pkBytes,
			"2 group public keys are mismatching")
	}

	// Start TS
	log.Info("TS starts")
	sync.Add(n)
	for current := 0; current < n; current++ {
		go tsRunChan(&processors[current], &sync, t)
	}
	// synchronize the main thread to end TS
	sync.Wait()
}

// Testing Threshold Signature statless api
// keys are generated using simple Feldman VSS
func testStatelessThresholdSignatureFeldmanVSS(t *testing.T) {
	log.SetLevel(log.ErrorLevel)
	log.Info("DKG starts")
	// number of nodes to test
	n := 5
	lead := 0
	var sync sync.WaitGroup
	chans := make([]chan *message, n)
	processors := make([]testDKGProcessor, 0, n)

	// create n processors for all nodes
	for current := 0; current < n; current++ {
		processors = append(processors, testDKGProcessor{
			current: current,
			chans:   chans,
			msgType: dkgType,
		})
		// create DKG in all nodes
		var err error
		processors[current].dkg, err = NewDKG(FeldmanVSS, n, current,
			&processors[current], lead)
		assert.Nil(t, err)
	}

	// create the node (buffered) communication channels
	for i := 0; i < n; i++ {
		chans[i] = make(chan *message, 2*n)
	}
	// start DKG in all nodes
	seed := []byte{1, 2, 3}
	sync.Add(n)
	for current := 0; current < n; current++ {
		err := processors[current].dkg.StartDKG(seed)
		assert.Nil(t, err)
		go tsDkgRunChan(&processors[current], &sync, t, 2)
	}

	// synchronize the main thread to end DKG
	sync.Wait()
	for i := 1; i < n; i++ {
		assert.Equal(t, processors[i].pkBytes, processors[0].pkBytes, "2 group public keys are mismatching")
	}

	// Start TS
	log.Info("TS starts")
	sync.Add(n)
	for i := 0; i < n; i++ {
		go tsStatelessRunChan(&processors[i], &sync, t)
	}
	// synchronize the main thread to end TS
	sync.Wait()
}

var messageToSign = []byte{1, 2, 3}

// This is a testing function
// It simulates processing incoming messages by a node during DKG
// It assumes proc.dkg is already running
func tsDkgRunChan(proc *testDKGProcessor,
	sync *sync.WaitGroup, t *testing.T, phase int) {
	for {
		select {
		case newMsg := <-proc.chans[proc.current]:
			log.Debugf("%d Receiving DKG from %d:", proc.current, newMsg.orig)
			err := proc.dkg.ReceiveDKGMsg(newMsg.orig, newMsg.data)
			assert.Nil(t, err)

		// if timeout, finalize DKG and sign the share
		case <-time.After(200 * time.Millisecond):
			switch phase {
			case 0:
				log.Infof("%d shares phase ended \n", proc.current)
				err := proc.dkg.NextTimeout()
				assert.Nil(t, err)
			case 1:
				log.Infof("%d complaints phase ended \n", proc.current)
				err := proc.dkg.NextTimeout()
				assert.Nil(t, err)
			case 2:
				log.Infof("%d dkg ended \n", proc.current)
				sk, groupPK, nodesPK, err := proc.dkg.EndDKG()
				assert.NotNil(t, sk)
				assert.NotNil(t, groupPK)
				assert.NotNil(t, nodesPK)
				assert.Nil(t, err, "End dkg failed: %v\n", err)
				if groupPK == nil {
					proc.pkBytes = []byte{}
				} else {
					proc.pkBytes, _ = groupPK.Encode()
				}
				n := proc.dkg.Size()
				kmac := NewBLS_KMAC(ThresholdSignatureTag)
				proc.ts, err = NewThresholdSigner(n, proc.current, kmac)
				assert.Nil(t, err)
				proc.ts.SetKeys(sk, groupPK, nodesPK)
				proc.ts.SetMessageToSign(messageToSign)
				// needed to test the statless api
				proc.keys = &statelessKeys{sk, groupPK, nodesPK}
			}
			sync.Done()
			return
		}
	}
}

// This is a testing function using the stateful api
// It simulates processing incoming messages by a node during TS
func tsRunChan(proc *testDKGProcessor, sync *sync.WaitGroup, t *testing.T) {
	// Sign a share and broadcast it
	sighShare, _ := proc.ts.SignShare()
	proc.msgType = tsType
	proc.Broadcast(sighShare)
	for {
		select {
		case newMsg := <-proc.chans[proc.current]:
			log.Debugf("%d Receiving TS from %d:", proc.current, newMsg.orig)
			verif, thresholdReached, err := proc.ts.AddSignatureShare(
				newMsg.orig, newMsg.data)
			assert.Nil(t, err)
			assert.True(t, verif,
				"the signature share sent from %d to %d is not correct", newMsg.orig,
				proc.current)
			if thresholdReached {
				thresholdSignature, err := proc.ts.ThresholdSignature()
				verif, err = proc.ts.VerifyThresholdSignature(thresholdSignature)
				assert.Nil(t, err)
				assert.True(t, verif, "the threshold signature is not correct")
				if verif {
					log.Infof("%d reconstructed a valid signature: %d\n", proc.current,
						thresholdSignature)
				}
			}

		// if timeout, finalize TS
		case <-time.After(time.Second):
			sync.Done()
			return
		}
	}
}

// This stucture holds the keys and is needed for the stateless test
type statelessKeys struct {
	// the current node private key (a DKG output)
	currentPrivateKey PrivateKey
	// the group public key (a DKG output)
	groupPublicKey PublicKey
	// the group public key shares (a DKG output)
	publicKeyShares []PublicKey
}

// This is a testing function using the stateless api
// It simulates processing incoming messages by a node during TS
func tsStatelessRunChan(proc *testDKGProcessor, sync *sync.WaitGroup, t *testing.T) {
	n := proc.dkg.Size()
	// Sign a share and broadcast it
	kmac := NewBLS_KMAC(ThresholdSignatureTag)
	ownSignShare, _ := proc.keys.currentPrivateKey.Sign(messageToSign, kmac)
	// the local valid signature shares
	signShares := make([]Signature, 0, n)
	signers := make([]int, 0, n)
	// add the node own share
	signShares = append(signShares, ownSignShare)
	signers = append(signers, proc.current)
	proc.msgType = tsType
	proc.Broadcast(ownSignShare)
	for {
		select {
		case newMsg := <-proc.chans[proc.current]:
			log.Debugf("%d Receiving TS from %d:", proc.current, newMsg.orig)
			verif, err := proc.keys.publicKeyShares[newMsg.orig].Verify(newMsg.data, messageToSign, kmac)
			assert.Nil(t, err)
			assert.True(t, verif,
				"the signature share sent from %d to %d is not correct", newMsg.orig,
				proc.current)
			// append the received signature share
			if verif {
				// check the signer is new
				isSeen := true
				for _, i := range signers {
					if i == newMsg.orig {
						isSeen = false
					}
				}
				if isSeen {
					signShares = append(signShares, newMsg.data)
					signers = append(signers, newMsg.orig)
				}
			}
			threshReached := EnoughShares(n, len(signShares))
			if threshReached {
				// Reconstruct the threshold signature
				thresholdSignature, err := ReconstructThresholdSignature(n, signShares, signers)
				verif, err = proc.keys.groupPublicKey.Verify(thresholdSignature, messageToSign, kmac)
				assert.Nil(t, err)
				assert.True(t, verif, "the threshold signature is not correct")
				if verif {
					log.Infof("%d reconstructed a valid signature: %d\n", proc.current,
						thresholdSignature)
				}
			}

		// if timeout, finalize TS
		case <-time.After(time.Second):
			sync.Done()
			return
		}
	}
}
